import telegram
from telegram.ext import Application, CommandHandler, ContextTypes
import logging
from typing import Dict, Any
from config.settings import settings

logger = logging.getLogger(__name__)

class TelegramBot:
    def __init__(self):
        self.bot = telegram.Bot(token=settings.TELEGRAM_BOT_TOKEN)
        self.chat_id = settings.TELEGRAM_CHAT_ID
        self.application = None
    
    async def initialize(self):
        """Initialize telegram bot"""
        self.application = Application.builder().token(settings.TELEGRAM_BOT_TOKEN).build()
        
        # Add command handlers
        self.application.add_handler(CommandHandler("start", self.start_command))
        self.application.add_handler(CommandHandler("scan", self.scan_command))
        self.application.add_handler(CommandHandler("health", self.health_command))
        self.application.add_handler(CommandHandler("training", self.training_command))
        
        logger.info("Telegram bot initialized")
    
    async def start_command(self, update, context):
        """Handle /start command"""
        welcome_text = """
ü§ñ *AI Betting Predictions Bot*

Commands available:
/scan - Start live scanning
/health - System health check  
/training - Start model training
/daily - Get daily digest
/backfill - Backfill historical data

System is powered by Bayesian Networks and Logistic Regression with live learning.
        """
        await update.message.reply_text(welcome_text, parse_mode='Markdown')
    
    async def scan_command(self, update, context):
        """Handle /scan command"""
        from main import betting_system
        await update.message.reply_text("üîÑ Starting live scan...")
        await betting_system.live_scanner.start_scan()
    
    async def health_command(self, update, context):
        """Handle /health command"""
        from main import betting_system
        health = await betting_system.health_monitor.get_health_status()
        
        health_text = f"""
üè• *System Health Report*

*Models:*
- Bayesian Network: {'‚úÖ' if health['models']['bayesian'] else '‚ùå'}
- Logistic Regression: {'‚úÖ' if health['models']['logistic'] else '‚ùå'}

*Database:* {'‚úÖ' if health['database'] else '‚ùå'}
*API Connection:* {'‚úÖ' if health['api'] else '‚ùå'}

*Performance:*
- Predictions Today: {health['performance']['predictions_today']}
- Accuracy Rate: {health['performance']['accuracy_rate']:.1%}
- Avg Confidence: {health['performance']['avg_confidence']:.1%}

*Last Update:* {health['last_update']}
        """
        await update.message.reply_text(health_text, parse_mode='Markdown')
    
    async def training_command(self, update, context):
        """Handle /training command"""
        from train_models import main as train_main
        await update.message.reply_text("üß† Starting model training...")
        train_main()
        await update.message.reply_text("‚úÖ Model training completed!")
    
    async def send_prediction(self, prediction: Dict[str, Any]):
        """Send prediction to telegram channel"""
        try:
            # Format prediction message
            message = self._format_prediction_message(prediction)
            
            # Send message
            await self.bot.send_message(
                chat_id=self.chat_id,
                text=message,
                parse_mode='Markdown'
            )
            
            logger.info(f"Prediction sent to Telegram: {prediction['fixture_id']}")
            
        except Exception as e:
            logger.error(f"Failed to send Telegram message: {e}")
    
    def _format_prediction_message(self, prediction: Dict[str, Any]) -> str:
        """Format prediction as markdown message"""
        live_indicator = "‚ö° LIVE" if prediction.get('live_minute') else "üìä PREMATCH"
        
        message = f"""
üéØ *AI BETTING PREDICTION* {live_indicator}

*Match:* {prediction['home_team']} vs {prediction['away_team']}
*League:* {prediction['league_name']}
{f"*Minute:* {prediction['live_minute']}' {prediction['current_score']}" if prediction.get('live_minute') else ""}

*Probabilities:*
üè† Home Win: {prediction['home_win_prob']:.1%}
ü§ù Draw: {prediction['draw_prob']:.1%}
‚úàÔ∏è Away Win: {prediction['away_win_prob']:.1%}
‚úÖ BTTS Yes: {prediction['btts_yes_prob']:.1%}
‚ùå BTTS No: {prediction['btts_no_prob']:.1%}
‚¨ÜÔ∏è Over 2.5: {prediction['over_25_prob']:.1%}
‚¨áÔ∏è Under 2.5: {prediction['under_25_prob']:.1%}

üí° *Recommended Bet:* `{prediction['recommended_bet']}`
üéØ *Confidence:* {prediction['confidence']:.1%}
üí∞ *Stake Level:* {self._get_stake_level(prediction['stake_confidence'])}

_Generated by AI Ensemble ‚Ä¢ {prediction['prediction_time']}_
        """
        
        return message
    
    def _get_stake_level(self, confidence: float) -> str:
        """Get stake level based on confidence"""
        if confidence > 0.8:
            return "HIGH"
        elif confidence > 0.65:
            return "MEDIUM"
        else:
            return "LOW"
    
    async def send_daily_digest(self, digest_data: Dict[str, Any]):
        """Send daily digest to telegram"""
        message = f"""
üìä *DAILY DIGEST*

*Today's Performance:*
- Predictions Made: {digest_data['predictions_today']}
- Bets Recommended: {digest_data['bets_recommended']}
- Accuracy: {digest_data['accuracy']:.1%}

*Top Leagues Today:*
{chr(10).join(f'- {league}: {count} games' for league, count in digest_data['top_leagues'][:3])}

*Model Health:* {'‚úÖ Excellent' if digest_data['model_health'] else '‚ö†Ô∏è Needs Attention'}

_Next update in 6 hours_
        """
        
        await self.bot.send_message(
            chat_id=self.chat_id,
            text=message,
            parse_mode='Markdown'
        )

telegram_bot = TelegramBot()
